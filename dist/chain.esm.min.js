var i=class{events={};on(t,e){typeof this.events[t]!="object"&&(this.events[t]=[]),this.events[t].push(e);let r=this;return function(){r.removeListener(t,e)}}removeListener(t,e){var r;typeof this.events[t]=="object"&&(r=this.events[t].indexOf(e),r>-1&&this.events[t].splice(r,1))}emit(t){if(typeof this.events[t]=="object"){var e,r,s,o=[].slice.call(arguments,1);for(r=this.events[t].slice(),s=r.length,e=0;e<s;e++)try{r[e].apply(this,o)}catch(h){console.error(t,o),console.error(h)}}}once(t,e){return this.on(t,function r(){this.removeListener(t,r),e.apply(this,arguments)})}};function u(n){return new Promise(t=>setTimeout(t,n))}var l=class{abortController=new AbortController;constructor(t){this.chain=t}cancel(){throw this.chain.returnValue=null,this.abortController.abort(),new Error("Cancel")}complete(t){throw this.chain.returnValue=t,this.abortController.abort(),new Error("Complete")}raiseError(t){throw this.chain.returnValue=null,this.abortController.abort(),t}sleep(t){return new Promise((e,r)=>{let s=setTimeout(e,t);this.abortController.signal.addEventListener("abort",()=>{clearTimeout(s),r(new Error("Cancel"))})})}fetch(t,e){return fetch(t,Object.assign({},e,{signal:this.abortController.signal}))}get ctx(){return this.chain.getCtx()}},a=class{#t=new i;tasks=[];returnValue;completedSuccessfully=!1;isRunning=!1;#r={};#e=new l(this);on(t,e){return this.#t.on(t,e)}add(t){return this.tasks.push(t),this}async run(t){if(t=t||{},this.isRunning)throw new Error("Already running");this.#e=new l(this),this.isRunning=!0;var e=void 0;this.completedSuccessfully=!1,this.returnValue=null,this.#r=t,this.#t.emit("run",{chain:this});for(var r=0;this.tasks[r];){try{if(this.#e.abortController.signal.aborted){this.#e.cancel();return}e=await this.tasks[r](e,this.#e)}catch(s){return this.isRunning=!1,s.message=="Complete"?(this.isRunning=!1,this.completedSuccessfully=!0,this.#t.emit("complete",{chain:this,error:null,task_id:r}),this.returnValue):s.message=="Cancel"?(this.isRunning=!1,this.completedSuccessfully=!1,this.#t.emit("cancel",{chain:this,error:null,task_id:r}),null):(this.isRunning=!1,this.completedSuccessfully=!1,this.returnValue=null,this.#t.emit("error",{chain:this,error:s,task_id:r}),null)}r++}return this.isRunning=!1,this.completedSuccessfully=!0,this.returnValue=e,this.#t.emit("complete",{chain:this,error:null,task_id:r-1}),e}async waitUntilComplete(){for(;this.isRunning;)await u(100)}cancel(){this.isRunning&&this.#e.abortController.abort()}getCtx(){return this.#r}};export{a as Chain};
