var n=class{events={};on(t,e){typeof this.events[t]!="object"&&(this.events[t]=[]),this.events[t].push(e);let r=this;return function(){r.removeListener(t,e)}}removeListener(t,e){var r;typeof this.events[t]=="object"&&(r=this.events[t].indexOf(e),r>-1&&this.events[t].splice(r,1))}emit(t){if(typeof this.events[t]=="object"){var e,r,s,i=[].slice.call(arguments,1);for(r=this.events[t].slice(),s=r.length,e=0;e<s;e++)try{r[e].apply(this,i)}catch(o){console.error(t,i),console.error(o)}}}once(t,e){return this.on(t,function r(){this.removeListener(t,r),e.apply(this,arguments)})}};var l=class{abortController=new AbortController;constructor(t){this.chain=t}checkAbortSignal(){this.abortController.signal.aborted&&this.cancel()}cancel(){throw new Error("Cancel")}complete(t){throw this.checkAbortSignal(),new Error("Complete",{cause:t})}sleep(t){return this.checkAbortSignal(),new Promise((e,r)=>{let s=()=>{clearTimeout(i),r(new Error("Cancel"))},i=setTimeout(()=>{this.abortController.signal.removeEventListener("abort",s),e()},t);this.abortController.signal.addEventListener("abort",s)})}fetch(t,e){return this.checkAbortSignal(),fetch(t,Object.assign({},e,{signal:this.abortController.signal}))}wrap(t){this.checkAbortSignal();let e=this;return function(...s){return new Promise((i,o)=>{let h=()=>{o(new Error("Cancel"))};e.abortController.signal.addEventListener("abort",h),t(...s).then(u=>{e.abortController.signal.removeEventListener("abort",h),i(u)}).catch(o)})}}get ctx(){return this.chain.ctx}},c=class{#n=new n;tasks=[];#t;#s=!1;#e=!1;#o={};#r=new l(this);constructor(t){t&&(this.#o=t)}on(t,e){return this.#n.on(t,e)}add(t){return this.tasks.push(t),this}#i(t,e){this.#n.emit(t,e)}async run(t,e){if(this.#e)return this.#i("error",{chain:this,error:new Error("Already running"),lastTaskIndex:-1}),null;this.#r=new l(this),this.#e=!0;var r=t;this.#s=!1,this.#t=null,e&&(this.#o=e),this.#i("run",{chain:this,lastTaskIndex:-1,error:null});var s=-1;if(this.tasks.length>0)for(s=0;this.tasks[s];){try{this.#r.checkAbortSignal(),r=await this.tasks[s](r,this.#r)}catch(i){return this.#r.abortController.signal.aborted||this.#r.abortController.abort(),this.#e=!1,i.message=="Complete"?(this.#s=!0,this.#t=i.cause,this.#i("complete",{chain:this,error:null,lastTaskIndex:s})):i.message=="Cancel"?(this.#s=!1,this.#t=null,this.#i("cancel",{chain:this,error:null,lastTaskIndex:s})):(this.#s=!1,this.#t=null,this.#i("error",{chain:this,error:i,lastTaskIndex:s})),this.#t}if(s+1>=this.tasks.length)break;s++}return this.#r.abortController.signal.aborted||this.#r.abortController.abort(),this.#e=!1,this.#s=!0,this.#t=r,this.#i("complete",{chain:this,error:null,lastTaskIndex:s}),this.#t}waitForChainToFinish(){return this.#e?new Promise(t=>{let e=()=>{this.#e||(r(),s(),i(),t())},r=this.#n.on("complete",e),s=this.#n.on("cancel",e),i=this.#n.on("error",e)}):new Promise(t=>{t()})}async cancel(){this.#e&&this.#r.abortController.abort("Cancel"),await this.waitForChainToFinish()}get ctx(){return this.#o}get returnValue(){return this.#t}get completedSuccessfully(){return this.#s}get isRunning(){return this.#e}};export{c as Chain};
