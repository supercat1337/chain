var n=class{events={};on(t,e){typeof this.events[t]!="object"&&(this.events[t]=[]),this.events[t].push(e);let r=this;return function(){r.removeListener(t,e)}}removeListener(t,e){var r;typeof this.events[t]=="object"&&(r=this.events[t].indexOf(e),r>-1&&this.events[t].splice(r,1))}emit(t){if(typeof this.events[t]=="object"){var e,r,s,i=[].slice.call(arguments,1);for(r=this.events[t].slice(),s=r.length,e=0;e<s;e++)try{r[e].apply(this,i)}catch(a){console.error(t,i),console.error(a)}}}once(t,e){return this.on(t,function r(){this.removeListener(t,r),e.apply(this,arguments)})}};function b(o){return new Promise(t=>setTimeout(t,o))}var l=class{abortController=new AbortController;constructor(t){this.chain=t}checkAbortSignal(){this.abortController.signal.aborted&&this.cancel()}cancel(){throw new Error("Cancel")}complete(t){throw this.checkAbortSignal(),new Error("Complete",{cause:t})}sleep(t){return this.checkAbortSignal(),new Promise((e,r)=>{let s=()=>{clearTimeout(i),r(new Error("Cancel"))},i=setTimeout(()=>{this.abortController.signal.removeEventListener("abort",s),e()},t);this.abortController.signal.addEventListener("abort",s)})}fetch(t,e){return this.checkAbortSignal(),fetch(t,Object.assign({},e,{signal:this.abortController.signal}))}wrap(t){this.checkAbortSignal();let e=this;return function(...s){return new Promise((i,a)=>{let h=()=>{a(new Error("Cancel"))};e.abortController.signal.addEventListener("abort",h),t(...s).then(u=>{e.abortController.signal.removeEventListener("abort",h),i(u)}).catch(a)})}}get ctx(){return this.chain.ctx}},c=class{#o=new n;tasks=[];#t;#s=!1;#r=!1;#n={};#e=new l(this);constructor(t){t&&(this.#n=t)}on(t,e){return this.#o.on(t,e)}add(t){return this.tasks.push(t),this}#i(t,e){this.#o.emit(t,e)}async run(t,e){if(this.#r)return this.#i("error",{chain:this,error:new Error("Already running"),lastTaskIndex:-1}),null;this.#e=new l(this),this.#r=!0;var r=t;this.#s=!1,this.#t=null,e&&(this.#n=e),this.#i("run",{chain:this,lastTaskIndex:-1,error:null});var s=-1;if(this.tasks.length>0)for(s=0;this.tasks[s];){try{this.#e.checkAbortSignal(),r=await this.tasks[s](r,this.#e)}catch(i){return this.#e.abortController.signal.aborted||this.#e.abortController.abort(),this.#r=!1,i.message=="Complete"?(this.#s=!0,this.#t=i.cause,this.#i("complete",{chain:this,error:null,lastTaskIndex:s})):i.message=="Cancel"?(this.#s=!1,this.#t=null,this.#i("cancel",{chain:this,error:null,lastTaskIndex:s})):(this.#s=!1,this.#t=null,this.#i("error",{chain:this,error:i,lastTaskIndex:s})),this.#t}if(s+1>=this.tasks.length)break;s++}return this.#e.abortController.signal.aborted||this.#e.abortController.abort(),this.#r=!1,this.#s=!0,this.#t=r,this.#i("complete",{chain:this,error:null,lastTaskIndex:s}),this.#t}async waitForChainToFinish(){for(;this.#r;)await b(100)}async cancel(){this.#r&&this.#e.abortController.abort("Cancel"),await this.waitForChainToFinish()}get ctx(){return this.#n}get returnValue(){return this.#t}get completedSuccessfully(){return this.#s}get isRunning(){return this.#r}};export{c as Chain};
